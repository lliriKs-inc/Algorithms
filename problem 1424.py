def solve(m, intervals, p):
    k = len(intervals)

    # Создаём события: для каждого пассажира 2 события — начало (+1) и конец (-1)
    # Каждое событие представляем как кортеж (индекс пассажира, тип события)
    # +1 означает посадку, -1 — высадку
    events = [(i, +1) for i in range(k)] + [(i, -1) for i in range(k)]

    # Сортируем события:
    # - по времени (s[i] для начала, f[i] для конца)
    # - при равенстве: высадки (-1) идут раньше посадок (+1), чтобы освободить место до новой посадки
    events.sort(key=lambda e: (
        intervals[e[0]][1] if e[1] == -1 else intervals[e[0]][0],
        e[1]
    ))

    # q — список индексов пассажиров, которые сейчас едут в маршрутке
    q = []

    # selected — список пассажиров, которых мы реально посадили и довезли
    selected = []

    # position[i] — индекс пассажира i в списке q, если он в маршрутке;
    # если не в маршрутке, значение по умолчанию m (то есть вне допустимого диапазона)
    position = [m] * k

    # Обрабатываем все события в хронологическом порядке
    for i, event_type in events:
        start, end = intervals[i]

        if event_type == -1:
            # Событие: пассажир i выходит

            if position[i] != m:
                # Только если он был в маршрутке
                selected.append(i)  # Добавляем его в финальный список

                # Удаляем его из q с помощью swap-and-pop (заменяем на последний и удаляем)
                pos = position[i]
                last = q[-1]

                q[pos] = last  # заменяем текущего пассажира последним
                position[last] = pos  # обновляем позицию последнего пассажира
                q.pop()  # удаляем последнего
            continue

        # Событие: пассажир i хочет сесть
        if len(q) < m:
            # Если есть свободное место в маршрутке
            position[i] = len(q)
            q.append(i)
            continue

        # Маршрутка полная — пытаемся найти пассажира, которого можно заменить
        # Ищем пассажира с самым поздним временем выхода
        idx_max = max(range(m), key=lambda j: intervals[q[j]][1])

        # Если текущий пассажир выйдет раньше самого "долго сидящего", то выгоднее взять его
        if end < intervals[q[idx_max]][1]:
            # Заменяем "долго сидящего" на текущего
            position[i] = idx_max
            position[q[idx_max]] = m  # помечаем старого как не выбранного
            q[idx_max] = i  # вставляем нового на его место

    # В конце считаем прибыль и выводим список пассажиров
    print(len(selected) * p)  # прибыль = количество посаженных * цена билета

    if selected:
        # Выводим 1-based индексы (в задаче индексация с 1)
        print(" ".join(str(i + 1) for i in selected))

def main():
    import sys
    data = sys.stdin.read().split()  # читаем все входные данные разом
    if not data:
        return

    n = int(data[0])  # N — число остановок (не используется в логике)
    m = int(data[1])  # M — вместимость маршрутки
    k = int(data[2])  # K — количество пассажиров
    p = int(data[3])  # P — цена билета

    # Считываем интервалы (пары S[i], F[i])
    intervals = []
    pos = 4
    for _ in range(k):
        s = int(data[pos])
        f = int(data[pos + 1])
        intervals.append((s, f))
        pos += 2

    solve(m, intervals, p)  # запускаем основное решение

if __name__ == '__main__':
    main()